{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Extended Clusters - A Netbox Plugin","text":"<p>TODO: Write plugin documentation, the outline here is provided as a guide and should be expanded upon.  If more detail is required you are encouraged to expand on the table of contents (TOC) in <code>mkdocs.yml</code> to add additional pages.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation contains a</p> <ul> <li>User Guide Overview,  Using the Plugin, and Getting Started.</li> <li>Administrator Guide - How to Install, Configure, Upgrade, or Uninstall the Plugin.</li> <li>Developer Guide - Extending the Plugin, Code Reference, Contribution Guide.</li> </ul>"},{"location":"#contributing-to-the-documentation","title":"Contributing to the Documentation","text":"<p>You can find all the Markdown source for the Plugin documentation under the <code>docs</code> folder in this repository. For simple edits, a Markdown capable editor is sufficient: clone the repository and edit away.</p> <p>If you need to view the fully-generated documentation site, you can build it with MkDocs. A container hosting the documentation can be started using the <code>invoke</code> commands (details in the Development Environment Guide) on http://localhost:8001. Using this container, as your changes to the documentation are saved, they will be automatically rebuilt and any pages currently being viewed will be reloaded in your browser.</p> <p>Any PRs with fixes or improvements are very welcome!</p>"},{"location":"admin/install/","title":"Install and Configure","text":"<p>Installing the Plugin in Netbox</p> <p>Here you will find detailed instructions on how to install and configure the Plugin.</p>"},{"location":"admin/install/#prerequisites","title":"Prerequisites","text":"<ul> <li>The plugin is compatible with Netbox 3.5.0 and higher.</li> <li>Databases supported: PostgreSQL</li> </ul>"},{"location":"admin/install/#access-requirements","title":"Access Requirements","text":"<p>No external systems access is required to use this plugin.</p>"},{"location":"admin/install/#install-guide","title":"Install Guide","text":"<p>Note</p> <p>Plugins can be installed manually or using Python's <code>pip</code>. See the netbox documentation for more details. The pip package name for this plugin is <code>netbox_plugin_extended_clusters</code>.</p> <p>The plugin is available as a Python package via PyPI and can be installed with <code>pip</code>:</p> <pre><code>pip install netbox-plugin-extended-clusters\n</code></pre> <p>To ensure the extended cluster plugin is automatically re-installed during future upgrades, create a file named <code>local_requirements.txt</code> (if not already existing) in the Netbox root directory (alongside <code>requirements.txt</code>) and list the <code>netbox_plugin_extended_clusters</code> package:</p> <pre><code>echo netbox-plugin-extended-clusters &gt;&gt; local_requirements.txt\n</code></pre> <p>Once installed, the plugin needs to be enabled in your Netbox configuration. The following block of code below shows the additional configuration required to be added to your <code>$NETBOX_ROOT/netbox/configuration.py</code> file:</p> <ul> <li>Append <code>\"netbox_plugin_extended_clusters\"</code> to the <code>PLUGINS</code> list.</li> <li>Append the <code>\"netbox_plugin_extended_clusters\"</code> dictionary to the <code>PLUGINS_CONFIG</code> dictionary and override any defaults.</li> </ul> <pre><code>PLUGINS = [\n    \"netbox_plugin_extended_clusters\",\n]\nPLUGINS_CONFIG = {\n    \"netbox_plugin_extended_clusters\": {\n        \"USERNAME\": \"foo\",\n        \"PASSWORD\": \"bar\",\n    }\n}\n</code></pre>"},{"location":"admin/install/#post-install-steps","title":"Post Install Steps","text":"<p>Once the Netbox configuration is updated, run the post install steps from the Netbox Home to run migrations and clear any cache:</p> <pre><code># Apply any database migrations\npython3 netbox/manage.py migrate\n# Trace any missing cable paths (not typically needed)\npython3 netbox/manage.py trace_paths --no-input\n# Collect static files\npython3 netbox/manage.py collectstatic --no-input\n# Delete any stale content types\npython3 netbox/manage.py remove_stale_contenttypes --no-input\n# Rebuild the search cache (lazily)\npython3 netbox/manage.py reindex --lazy\n# Delete any expired user sessions\npython3 netbox/manage.py clearsessions\n# Clear the cache\npython3 netbox/manage.py clearcache\n</code></pre> <p>Then restart the Netbox services:</p> <pre><code>sudo systemctl restart netbox netbox-rq\n</code></pre>"},{"location":"admin/install/#app-configuration","title":"App Configuration","text":"<p>Developer Note - Remove Me!</p> <p>Any configuration required to get the App set up. Edit the table below as per the examples provided.</p> <p>The plugin behaviour can be controlled with the following list of settings:</p> Key Example Default Description <code>example_setting</code> <code>True</code> <code>True</code> A boolean to represent whether or not to use the example setting within the plugin."},{"location":"admin/uninstall/","title":"Uninstall the Plugin from Netbox","text":"<p>Here you will find any steps necessary to cleanly remove the Plugin from your Netbox environment.</p>"},{"location":"admin/uninstall/#uninstall-guide","title":"Uninstall Guide","text":"<p>To uninstall the plugin, remove/comment out the configuration entries for the plugin in that were added in your <code>$NETBOX_ROOT/netbox/configuration.py</code> file, to the <code>PLUGINS</code> &amp; <code>PLUGINS_CONFIG</code> sections.</p> <pre><code>PLUGINS = [\n    #\"netbox_plugin_extended_clusters\",\n    'other plugins here',\n]\nPLUGINS_CONFIG = {\n    # \"netbox_plugin_extended_clusters\": {\n    #     \"USERNAME\": \"foo\",\n    #     \"PASSWORD\": \"bar\",\n    # }\n    'other plugins here':{\n        'other plugin': 'variable\n    },\n}\n</code></pre> <p>Now run the post install steps to clear the plugin from Netbox Cache.</p>"},{"location":"admin/uninstall/#database-clean-up","title":"Database Clean-up","text":"<p>To ensure the database is clean after the plugin is removed is removed, drop all tables created by the plugin: <code>netbox_plugin_extended_clusters_*</code>.</p>"},{"location":"admin/upgrade/","title":"Upgrading the Plugin","text":"<p>Here you will find any steps necessary to upgrade the plugin in your Netbox environment.</p>"},{"location":"admin/upgrade/#upgrade-guide","title":"Upgrade Guide","text":"<pre><code>pip install --upgrade netbox-plugin-extended-clusters\n</code></pre> <p>When a new release comes out it may be necessary to run a migration of the database to account for any changes in the data models used by this plugin,  after updating the <code>netbox_plugin_extended_clusters</code> package via <code>pip</code>.</p> <p>Run the post upgrade steps from the Netbox Home to run migrations, and clear any cache:</p> <pre><code># Apply any database migrations\npython3 netbox/manage.py migrate\n# Trace any missing cable paths (not typically needed)\npython3 netbox/manage.py trace_paths --no-input\n# Collect static files\npython3 netbox/manage.py collectstatic --no-input\n# Delete any stale content types\npython3 netbox/manage.py remove_stale_contenttypes --no-input\n# Rebuild the search cache (lazily)\npython3 netbox/manage.py reindex --lazy\n# Delete any expired user sessions\npython3 netbox/manage.py clearsessions\n# Clear the cache\npython3 netbox/manage.py clearcache\n</code></pre> <p>Then restart the Netbox services:</p> <pre><code>sudo systemctl restart netbox netbox-rq\n</code></pre>"},{"location":"admin/release_notes/","title":"Release Notes","text":"<p>All the published release notes can be found via the navigation menu. All patch releases are included in the same minor release (e.g. <code>v1.2</code>) document.</p>"},{"location":"admin/release_notes/version_0.9/","title":"v0.9 Release Notes","text":"<ul> <li>Initial release</li> </ul>"},{"location":"admin/release_notes/version_0.9/#announcements","title":"Announcements","text":"<ul> <li>Netbox Extended Clusters 0.9.X will officially not support Netbox versions before 3.5.x.</li> </ul>"},{"location":"dev/contributing/","title":"Contributing to the Plugin","text":"<p>The project is packaged with a light development environment based on <code>docker-compose</code> to help with the local development of the project and to run tests.</p> <p>The project is following Network to Code software development guidelines and is leveraging the following:</p> <ul> <li>Python linting and formatting: <code>black</code>, <code>flake8</code>, and <code>pydocstyle</code>.</li> <li>YAML linting is done with <code>yamllint</code>.</li> <li>Django unit test to ensure the plugin is working properly.</li> </ul> <p>Documentation is built using mkdocs. The Docker based development environment automatically starts a container hosting a live version of the documentation website on http://localhost:8001 that auto-refreshes when you make any changes to your local files.</p>"},{"location":"dev/contributing/#branching-policy","title":"Branching Policy","text":"<p>The branching policy includes the following tenets:</p> <ul> <li>The <code>develop</code> branch is the branch from which new features should be branched.</li> <li>The <code>feature/jira-ticket</code> branch is the branch for new features.</li> <li>The <code>main</code> branch is the branch of the latest released version.</li> <li>The <code>release-&lt;major&gt;.&lt;minor&gt;</code> branch will have all of the latest bug fixes and security patches, and may or may not represent the released version.</li> <li>PRs intended to add new features should be branched from and merged to the <code>develop</code> branch.</li> <li>PRs intended to add new features that break backward compatibility should be discussed before a PR is created.</li> <li>PRs intended to address bug fixes and security patches should be branched from and merged to the <code>main</code> branch as <code>bugfix/bug#</code>.</li> </ul> <p>Netbox Extended Clusters will observe semantic versioning, as of 1.0. This may result in an quick turn around in minor versions to keep pace with an ever growing feature set.</p>"},{"location":"dev/contributing/#release-policy","title":"Release Policy","text":"<p>Netbox Extended Clusters has currently no intended scheduled release schedule, and will release new features in minor versions.</p> <p>When a new release of any kind (e.g. from <code>release-&lt;major&gt;.&lt;minor&gt;</code> to <code>main</code>) is created the following should happen.</p> <ul> <li>A release PR is created:<ul> <li>Add and/or update to the changelog in <code>docs/admin/release_notes/version_&lt;major&gt;.&lt;minor&gt;.md</code> file to reflect the changes.</li> <li>Update the mkdocs.yml file to include updates when adding a new release_notes version file.</li> <li>Change the version from <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;-beta</code> to <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> in pyproject.toml.</li> <li>Set the PR to the proper branch, e.g. either <code>main</code> or <code>stable-&lt;major&gt;.&lt;minor&gt;</code>.</li> </ul> </li> <li>Ensure the tests for the PR pass.</li> <li>Merge the PR.</li> <li>Create a new tag:<ul> <li>The tag should be in the form of <code>v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>.</li> <li>The title should be in the form of <code>v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>.</li> <li>The description should be the changes that were added to the <code>version_&lt;major&gt;.&lt;minor&gt;.md</code> document.</li> </ul> </li> <li>Once merged into <code>main</code>, then push from <code>main</code> to <code>develop</code>, in order to retain the merge commit created when the PR was merged.</li> </ul>"},{"location":"dev/design/","title":"Introduction","text":""},{"location":"dev/design/#purpose","title":"Purpose","text":"<p>A extended cluster represents a logical grouping of physical resources within which shared services will run. Physical devices may be associated with clusters as server hosts, network devices, and storage arrays. This plugin will allow users to track in which cluster(s) a particular device may reside.</p>"},{"location":"dev/design/#intended-audience-and-reading-suggestions","title":"Intended Audience and Reading suggestions","text":"<p>Developer Note - Remove Me!</p> <p>Information on design conventions.</p>"},{"location":"dev/design/#project-scope","title":"Project Scope","text":"<p>Developer Note - Remove Me!</p> <p>Information on design conventions.</p>"},{"location":"dev/design/#overall-description","title":"Overall Description","text":""},{"location":"dev/design/#feature-perspective","title":"Feature Perspective","text":"<p>Developer Note - Remove Me!</p> <p>Feature Perspective</p>"},{"location":"dev/design/#characteristics","title":"Characteristics","text":"<p>Developer Note - Remove Me!</p> <p>Characteristics</p>"},{"location":"dev/design/#operating-environment-and-dependencies","title":"Operating Environment and Dependencies","text":"<p>Developer Note - Remove Me!</p> <p>Operating Environment and Dependencies</p>"},{"location":"dev/design/#entity-relationship-diagram","title":"Entity Relationship Diagram","text":"<pre><code>---\ntitle: Extended Clusters ERD\n---\nerDiagram\n    CLUSTER ||--|{ CLUSTER_STATUS : contains\n    CLUSTER ||--|{ CLUSTER_TYPE : contains\n    CLUSTER ||--|{ CLUSTER_NODES : contains\n    CLUSTER_NODES ||--|{ DCIM_DEVICE : contains\n    CLUSTER ||--|{ CLUSTER_NAME : contains</code></pre>"},{"location":"dev/design/#design-and-implementation-constraints","title":"Design and Implementation Constraints","text":"<p>Developer Note - Remove Me!</p> <p>Design and Implementation Constraints</p>"},{"location":"dev/dev_environment/","title":"Building Your Development Environment","text":""},{"location":"dev/dev_environment/#quickstart-guide","title":"Quickstart Guide","text":"<p>The development environment can be used in two ways:</p> <ol> <li>(Recommended) All services, including the Django Plugin, are spun up using Docker containers and a volume mount so you can develop locally.</li> <li>With a local Poetry environment if you wish to develop outside of Docker, with the caveat of using external services provided by Docker for the PostgreSQL database service.</li> </ol> <p>This is a quick reference guide if you're already familiar with the development environment provided, which you can read more about later in this document.</p>"},{"location":"dev/dev_environment/#invoke","title":"Invoke","text":"<p>The Invoke library is used to provide some helper commands based on the environment. There are a few configuration parameters which can be passed to Invoke to override the default configuration:</p> <ul> <li><code>project_name</code>: the default docker compose project name (default: <code>wmf</code>)</li> <li><code>python_ver</code>: the version of Python to use as a base for any built docker containers (default: 3.8)</li> <li><code>local</code>: a boolean flag indicating if invoke tasks should be run on the host or inside the docker containers (default: False, commands will be run in docker containers)</li> <li><code>compose_dir</code>: the full path to a directory containing the project compose files</li> <li><code>compose_files</code>: a list of compose files applied in order (see Multiple Compose files for more information)</li> </ul> <p>Using Invoke these configuration options can be overridden using several methods. Perhaps the simplest is setting an environment variable <code>INVOKE_WMF_VARIABLE_NAME</code> where <code>VARIABLE_NAME</code> is the variable you are trying to override. The only exception is <code>compose_files</code>, because it is a list it must be overridden in a YAML file. There is an example <code>invoke.yml</code> (<code>invoke.example.yml</code>) in this directory which can be used as a starting point.</p>"},{"location":"dev/dev_environment/#docker-development-environment","title":"Docker Development Environment","text":"<p>Tip</p> <p>This is the recommended option for development.</p> <p>This project is managed by Python Poetry and has a few requirements to setup your development environment:</p> <ol> <li>Install Poetry, see the Poetry Documentation for your operating system.</li> <li>Install Docker, see the Docker documentation for your operating system.</li> </ol> <p>Once you have Poetry and Docker installed you can run the following commands (in the root of the repository) to install all other development dependencies in an isolated Python virtual environment:</p> <pre><code>poetry shell\npoetry install\ncp development/creds.example.env development/creds.env\ninvoke build\ninvoke start\n</code></pre> <p>The Django app can now be accessed at http://localhost:8080 and the live documentation at http://localhost:8001.</p> <p>To either stop or destroy the development environment use the following options.</p> <ul> <li>invoke stop - Stop the containers, but keep all underlying systems intact</li> <li>invoke destroy - Stop and remove all containers, volumes, etc. (This results in data loss due to the volume being deleted)</li> </ul>"},{"location":"dev/dev_environment/#local-poetry-development-environment","title":"Local Poetry Development Environment","text":"<ul> <li>Create an <code>invoke.yml</code> file with the following contents at the root of the repo and edit as necessary</li> </ul> <p>Run the following commands:</p> <pre><code>poetry shell\npoetry install\nexport $(cat development/dev.env | xargs)\nexport $(cat development/creds.env | xargs)\ninvoke start &amp;&amp; sleep 5\npython manage.py migrate\n</code></pre> <p>You can now run <code>python manage.py</code> commands as you would from the Django documentation for example to start the development server:</p> <pre><code>python manage.py runserver 0.0.0.0:8080 --insecure\n</code></pre> <p>The Django app can now be accessed at http://localhost:8080.</p> <p>It is typically recommended to launch the runserver command in a separate shell so you can keep developing and manage the webserver separately.</p>"},{"location":"dev/dev_environment/#updating-the-documentation","title":"Updating the Documentation","text":"<p>Documentation dependencies are pinned to exact versions to ensure consistent results. For the development environment, they are defined in the <code>pyproject.toml</code> file.</p>"},{"location":"dev/dev_environment/#cli-helper-commands","title":"CLI Helper Commands","text":"<p>The project features a CLI helper based on Invoke to help setup the development environment. The commands are listed below in 3 categories:</p> <ul> <li><code>dev environment</code></li> <li><code>utility</code></li> </ul> <p>Each command can be executed with <code>invoke &lt;command&gt;</code>. All commands support the arguments <code>--python-ver</code> if you want to manually define the version of Python to use. Each command also has its own help <code>invoke &lt;command&gt; --help</code></p>"},{"location":"dev/dev_environment/#local-development-environment","title":"Local Development Environment","text":"<pre><code>  build            Build all docker images.\n  debug            Start the app and its dependencies in debug mode.\n  destroy          Destroy all containers and volumes.\n  restart          Restart the app and its dependencies in detached mode.\n  start            Start the app and its dependencies in detached mode.\n  stop             Stop the app and its dependencies.\n</code></pre>"},{"location":"dev/dev_environment/#utility","title":"Utility","text":"<pre><code>  cli              Launch a zsh shell inside the running plugin container.\n  create-user      Create a new user in django (default: admin), will prompt for password.\n  makemigrations   Run Make Migration in Django.\n  migrate          Run Migrations in Django.\n</code></pre>"},{"location":"dev/dev_environment/#project-overview","title":"Project Overview","text":"<p>This project provides the ability to develop and manage the app server locally (with supporting services being Dockerised) or by using only Docker containers to manage the app. The main difference between the two environments is the ability to debug and use pdb when developing locally. Debugging with pdb within the Docker container is more complicated, but can still be accomplished by either entering into the container (via <code>docker exec</code>) or attaching your IDE to the container and running the the app service manually within the container.</p> <p>The upside to having the app service handled by Docker rather than locally is that you do not have to manage the app server. The Docker logs provide the majority of the information you will need to help troubleshoot, while getting started quickly and not requiring you to perform several manual steps and remembering to have the app server running in a separate terminal while you develop.</p> <p>Note</p> <p>The local environment still uses Docker containers for the supporting services (Postgres, Redis, and RQ Worker), but the Django Plugin server is handled locally by you, the developer.</p> <p>Follow the directions below for the specific development environment that you choose.</p>"},{"location":"dev/dev_environment/#poetry","title":"Poetry","text":"<p>Poetry is used in lieu of the \"virtualenv\" commands and is leveraged in both environments. The virtual environment will provide all of the Python packages required to manage the development environment such as Invoke. See the Local Development Environment section to see how to install the app if you're going to be developing locally (i.e. not using the Docker container).</p> <p>The <code>pyproject.toml</code> file outlines all of the relevant dependencies for the project:</p> <ul> <li><code>tool.poetry.dependencies</code> - the main list of dependencies.</li> <li><code>tool.poetry.dev-dependencies</code> - development dependencies, to facilitate linting, testing, and documentation building.</li> </ul> <p>The <code>poetry shell</code> command is used to create and enable a virtual environment managed by Poetry, so all commands ran going forward are executed within the virtual environment. This is similar to running the <code>source venv/bin/activate</code> command with virtualenvs. To install project dependencies in the virtual environment, you should run <code>poetry install</code> - this will install both project and development dependencies.</p> <p>For more details about Poetry and its commands please check out its online documentation.</p>"},{"location":"dev/dev_environment/#full-docker-development-environment","title":"Full Docker Development Environment","text":"<p>This project is set up with a number of Invoke tasks consumed as simple CLI commands to get developing fast. You'll use a few <code>invoke</code> commands to get your environment up and running.</p>"},{"location":"dev/dev_environment/#copy-the-credentials-file-for-the-app","title":"Copy the credentials file for the app","text":"<p>First, you need to create the <code>development/creds.env</code> file - it stores a bunch of private information such as passwords and tokens for your local the app install. You can make a copy of the <code>development/creds.example.env</code> and modify it to suit you.</p> <pre><code>cp development/creds.example.env development/creds.env\n</code></pre>"},{"location":"dev/dev_environment/#building-the-docker-image","title":"Building the Docker Image","text":"<p>The first thing you need to do is build the necessary Docker image for the app that installs the specific <code>python_ver</code>. The image is used for django and the docs used by Docker Compose.</p> <pre><code>\u279c invoke build\n... &lt;omitted for brevity&gt;\n#19 exporting to image\n#19 exporting layers\n#19 exporting layers 2.5s done\n#19 writing image sha256:5e1e326448501f8769f575ff0b61240c6fd09ca8b5a1291b969833b459f5c881 done\n#19 naming to docker.io/library/ext-cluster-ui\n#19 naming to docker.io/library/ext-cluster-ui done\n#19 DONE 2.5s\n</code></pre>"},{"location":"dev/dev_environment/#starting-the-development-environment","title":"Starting the Development Environment","text":"<p>Next, you need to start up your Docker containers.</p> <pre><code>\u279c invoke start\nStarting Netbox in detached mode...\nRunning docker-compose command \"up --detach\"\nContainer ext-cluster-redis  Recreate\n Container ext-cluster-db  Recreate\n Container ext-cluster-docs  Recreate\n Container ext-cluster-redis  Recreated\n Container ext-cluster-db  Recreated\n Container ext-cluster-ui  Recreate\n Container ext-cluster-docs  Recreated\n Container ext-cluster-ui  Recreated\n Container ext-cluster-redis  Starting\n Container ext-cluster-db  Starting\n Container ext-cluster-docs  Starting\n Container ext-cluster-redis  Started\n Container ext-cluster-db  Started\n Container ext-cluster-db  Waiting\n Container ext-cluster-docs  Started\n Container ext-cluster-db  Healthy\n Container ext-cluster-ui  Starting\n Container ext-cluster-ui  Started\n</code></pre> <p>This will start all of the Docker containers used for hosting the app. You should see the following containers running after <code>invoke start</code> is finished.</p> <pre><code>\u279c docker ps\nCONTAINER ID   IMAGE                COMMAND                  CREATED          STATUS                    PORTS                    NAMES\nb39a80476277   ext-cluster-ui      \"/opt/entrypoint.sh\"     18 seconds ago   Up 6 seconds              0.0.0.0:8080-&gt;8080/tcp   ext-cluster-ui\n100632ca4f42   ext-cluster-ui      \"mkdocs serve -v -a \u2026\"   18 seconds ago   Up 17 seconds             0.0.0.0:8001-&gt;8001/tcp   ext-cluster-docs\n21492abea2f6   postgres:14-alpine   \"docker-entrypoint.s\u2026\"   18 seconds ago   Up 17 seconds (healthy)   0.0.0.0:5432-&gt;5432/tcp   ext-cluster-db\na620e0c82e6d   redis:7-alpine       \"docker-entrypoint.s\u2026\"   18 seconds ago   Up 17 seconds             0.0.0.0:6379-&gt;6379/tcp   ext-cluster-redis\n</code></pre> <p>Once the containers are fully up, you should be able to open up a web browser, and view:</p> <ul> <li>The app homepage at http://localhost:8080</li> <li>A live version of the documentation at http://localhost:8001</li> </ul> <p>Note</p> <p>Sometimes the containers take a minute or two, to fully spin up. If the page doesn't load right away, wait a minute and try again.</p>"},{"location":"dev/dev_environment/#creating-a-superuser","title":"Creating a Superuser","text":"<p>If you need to create a superuser, run the follow commands.</p> <pre><code>\u279c invoke createsuperuser\nRunning docker-compose command \"ps --services --filter status=running\"\nRunning docker-compose command \"exec ext-cluster-ui python /opt/netbox/netbox/manage.py createsuperuser --username admin\"\nEmail address: email@example.com\nPassword (again):\nSuperuser created successfully.\n</code></pre>"},{"location":"dev/dev_environment/#invoke-stopping-the-development-environment","title":"Invoke - Stopping the Development Environment","text":"<p>The last command to know for now is <code>invoke stop</code>.</p> <pre><code>\u279c invoke stop\nStopping Netbox...\nRunning docker-compose command \"down\"\nContainer ext-cluster-ui  Stopping\n Container ext-cluster-docs  Stopping\n Container ext-cluster-ui  Stopped\n Container ext-cluster-ui  Removing\n Container ext-cluster-ui  Removed\n Container ext-cluster-db  Stopping\n Container ext-cluster-redis  Stopping\n Container ext-cluster-db  Stopped\n Container ext-cluster-db  Removing\n Container ext-cluster-db  Removed\n Container ext-cluster-redis  Stopped\n Container ext-cluster-redis  Removing\n Container ext-cluster-redis  Removed\n Container ext-cluster-docs  Stopped\n Container ext-cluster-docs  Removing\n Container ext-cluster-docs  Removed\n Network netbox_plugin_extended_clusters_default  Removing\n Network netbox_plugin_extended_clusters_default  Removed\n</code></pre> <p>This will safely shut down all of your running Docker containers for this project. When you are ready to spin containers back up, it is as simple as running <code>invoke start</code> again as seen previously.</p> <p>Warning</p> <p>If you're wanting to reset the database and configuration settings, you can use the <code>invoke destroy</code> command, but you will lose any data stored in those containers, so make sure that is what you want to do.</p>"},{"location":"dev/dev_environment/#real-time-updates-how-cool","title":"Real-Time Updates? How Cool","text":"<p>Your environment should now be fully setup, all necessary Docker containers are created and running, and you're logged into the app in your web browser. Now what?</p> <p>Now you can start developing  in the project folder!</p> <p>The magic here is the root directory is mounted inside your Docker containers when built and ran, so any changes made to the files in here are directly updated to the app plugin code running in Docker. This means that as you modify the code in your plugin folder, the changes will be instantly updated in the app.</p> <p>Warning</p> <p>There are a few exceptions to this, as outlined in the section To Rebuild or Not To Rebuild.</p> <p>The back-end Django process is setup to automatically reload itself (it only takes a couple of seconds) every time a file is updated (saved). So for example, if you were to update one of the files like <code>models.py</code>, then save it, the changes will be visible right away in the web browser!</p> <p>Info</p> <p>You may get connection refused while Django reloads, but it should be refreshed fairly quickly.</p>"},{"location":"dev/dev_environment/#docker-logs","title":"Docker Logs","text":"<p>When trying to debug an issue, one helpful thing you can look at are the logs within the Docker containers.</p> <pre><code>\u279c docker logs &lt;name of container&gt; -f\n</code></pre> <p>Note</p> <p>The <code>-f</code> tag will keep the logs open, and output them in realtime as they are generated.</p> <p>So for example, our plugin is named <code>customer_clusters</code>, the command would most likely be <code>docker logs customer-clusters-ui -f</code>. You can find the name of all running containers via <code>docker ps</code>.</p> <p>If you want to view the logs specific to the database container, simply use the name of that container instead.</p>"},{"location":"dev/dev_environment/#to-rebuild-or-not-to-rebuild","title":"To Rebuild or Not to Rebuild","text":"<p>Most of the time, you will not need to rebuild your images. Simply running <code>invoke start</code> and <code>invoke stop</code> is enough to keep your environment going.</p> <p>However there are a couple of instances when you will want to.</p>"},{"location":"dev/dev_environment/#updating-environment-variables","title":"Updating Environment Variables","text":"<p>To add environment variables to your containers, thus allowing the app to use them, you will update/add them in the <code>development/development.env</code> file. However, doing so is considered updating the underlying container shell, instead of Django (which auto restarts itself on changes).</p> <p>To get new environment variables to take effect, you will need stop any running images, rebuild the images, then restart them. This can easily be done with 3 commands:</p> <pre><code>\u279c invoke stop\n\u279c invoke build\n\u279c invoke start\n</code></pre> <p>Once completed, the new/updated environment variables should now be live.</p>"},{"location":"dev/dev_environment/#installing-additional-python-packages","title":"Installing Additional Python Packages","text":"<p>If you want your plugin to leverage another Python package, you can easily add them into your Docker environment.</p> <pre><code>\u279c poetry shell\n\u279c poetry add &lt;package_name&gt;\n</code></pre> <p>Once the dependencies are resolved, stop the existing containers, rebuild the Docker image, and then start all containers again.</p> <pre><code>\u279c invoke stop\n\u279c invoke build\n\u279c invoke start\n</code></pre>"},{"location":"dev/dev_environment/#updating-python-version","title":"Updating Python Version","text":"<p>To update the Python version, you can update it within <code>tasks.py</code>.</p> <pre><code>namespace = Collection(\"wmf\")\nnamespace.configure(\n    {\n        \"wmf\": {\n            ...\n            \"python_ver\": \"3.10\",\n     ...\n        }\n    }\n)\n</code></pre>"},{"location":"dev/dev_environment/#other-miscellaneous-commands-to-know","title":"Other Miscellaneous Commands To Know","text":""},{"location":"dev/dev_environment/#shell","title":"Shell","text":"<p>To drop into a shell (in the Django Docker container) run:</p> <pre><code>\u279c invoke cli\n</code></pre>"},{"location":"dev/extending/","title":"Extending the Plugin","text":"<p>Developer Note - Remove Me!</p> <p>Information on how to extend the Plugin functionality.</p> <p>Extending the application is welcome, however it is best to open an issue first, to ensure that a PR would be accepted and makes sense in terms of features and design.</p>"}]}